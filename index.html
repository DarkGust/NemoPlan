<!doctype html>
<html lang="da">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Dykker grupper - Drag & Drop</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#0ea5a4;--danger:#ff3b30;--muted:#9aa4b2}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue';background:linear-gradient(180deg,#071021 0%, #071728 100%);color:#e6eef6}
    .app{display:flex;gap:16px;padding:14px;box-sizing:border-box}

    /* Left roster */
    .roster{width:320px;min-width:260px;background:linear-gradient(180deg,#041226,#081827);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,.6)}
    h2{margin:6px 0 10px;font-size:18px}
    .search{display:flex;gap:8px;align-items:center;margin-bottom:8px}
    .search input{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.06);background:transparent;color:inherit}
    .roster-list{display:flex;flex-direction:column;gap:8px;max-height:78vh;overflow:auto;padding-right:6px}

    .person{padding:10px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01));display:flex;align-items:center;gap:10px;border:1px solid rgba(255,255,255,.03);cursor:grab;touch-action:none}
    .person.dragging{opacity:.35}
    .badge{font-weight:700;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.02)}
    .trainer{box-shadow:0 0 0 3px rgba(14,165,164,.06) inset}

    /* Right groups */
    .groups{flex:1;display:grid;grid-template-columns:repeat(2,1fr);gap:14px}
    .group{background:linear-gradient(180deg,#071728,#051523);padding:12px;border-radius:12px;min-height:180px;position:relative;border:2px solid rgba(255,255,255,.03)}
    .group.header{display:flex;justify-content:space-between;align-items:center}
    .group h3{margin:0}
    .slots{display:flex;flex-direction:column;gap:10px;margin-top:8px}
    .pair{display:flex;gap:8px;align-items:center;padding:8px;border-radius:10px;border:1px dashed rgba(255,255,255,.03);min-height:54px;background:linear-gradient(180deg,rgba(255,255,255,.01),transparent)}
    .pair .slot{flex:1;min-height:44px;border-radius:8px;padding:6px;border:1px solid rgba(255,255,255,.02);background:rgba(255,255,255,.01);display:flex;align-items:center;gap:6px;flex-wrap:nowrap}
    .pair .slot.empty{opacity:.45}
    .group.good{box-shadow:0 0 0 4px rgba(14,165,164,.06) inset}
    .group.missing-trainer{box-shadow:0 0 0 4px rgba(255,59,48,.28) inset}

    .controls{display:flex;gap:8px;align-items:center;margin-top:8px}
    .controls input[type="time"]{padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,.06);background:transparent;color:inherit}
    .now-btn{padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,.06);background:rgba(255,255,255,.02);cursor:pointer}
    .dial{display:flex;align-items:center;gap:8px}
    .dial input[type=range]{width:140px}

    /* floating drag ghost */
    .ghost{position:fixed;pointer-events:none;z-index:9999;transform:translate(-50%,-50%);opacity:.95}

    /* small screens */
    @media (max-width:800px){.app{flex-direction:column}.roster{width:100%}.groups{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="app">
    <aside class="roster" id="roster">
      <h2>Tilgængelige dykkere & trænere</h2>
      <div class="search"><input id="filter" placeholder="Filtrer navn..." aria-label="Filtrer" /></div>
      <div class="roster-list" id="rosterList" role="list"></div>
      <p style="font-size:12px;color:var(--muted);margin-top:10px">Træk en person til højre for at placere dem. Flytning (ikke kopiering).</p>
    </aside>

    <main class="groups" id="groups">
      <!-- 4 grupper genereres af JS -->
    </main>
  </div>

  <template id="personTpl">
    <div class="person" data-role="" draggable="false" tabindex="0">
      <div class="name">Navn</div>
      <div class="badge">(*)</div>
    </div>
  </template>

  <script>
    // Initial data: 18 divers, 6 trainers
    const people = [
      {name:'Mikkel Andersen (*)', level:'*'},
      {name:'Signe Møller (*)', level:'*'},
      {name:'Jonas Pedersen (*)', level:'*'},
      {name:'Astrid Lund (*)', level:'*'},
      {name:'Kasper Holm (*)', level:'*'},
      {name:'Lise Kragh (**) ', level:'**'},
      {name:'Peter Søndergaard (**) ', level:'**'},
      {name:'Nina Falk (**) ', level:'**'},
      {name:'Rasmus Dahl (**) ', level:'**'},
      {name:'Camilla Voss (***)', level:'***'},
      {name:'Henrik Bjerre (***)', level:'***'},
      {name:'Emma Dalsgaard (***)', level:'***'},
      {name:'Jon (T)', level:'T'},
      {name:'Lotte (T)', level:'T'},
      {name:'Thomas (T)', level:'T'},
      {name:'Freja (T)', level:'T'},
      {name:'Anders (T)', level:'T'},
      {name:'Maja (T)', level:'T'},
      // ensure 18 divers (we have 12 divers + 6 trainers = 18 persons total)
    ];

    // Sorting order: *, **, ***, then (T)
    function sortRoster(a,b){
      const rank = v=> v === 'T' ? 99 : (v === '*'?1: v==='**'?2: v==='***'?3:50)
      return rank(a.level) - rank(b.level) || a.name.localeCompare(b.name)
    }

    const rosterList = document.getElementById('rosterList')
    const filterInput = document.getElementById('filter')

    // Create 4 groups
    const groupsEl = document.getElementById('groups')
    const GROUP_COUNT = 4
    const PAIRS_PER_GROUP = 3
    const groupState = [] // track assigned people

    for(let g=1; g<=GROUP_COUNT; g++){
      const el = document.createElement('section')
      el.className = 'group missing-trainer'
      el.dataset.group = g
      el.innerHTML = `
        <div class="header"><h3>Gruppe ${g}</h3><div class="controls">
          <label>Start <input type="time" class="startTime" step="60"></label>
          <button class="now-btn start-now">Nu!</button>
          <div class="dial"> <input type="range" min="0" max="1439" class="startDial"> </div>
        </div></div>
        <div class="slots"></div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px">
          <div style="font-size:13px;color:var(--muted)">Træner i gruppe: <span class="trainerCount">0</span></div>
          <div style="font-size:12px;color:var(--muted)">Dynamisk ring vises hvis træner mangler</div>
        </div>
      `
      groupsEl.appendChild(el)
      const slots = el.querySelector('.slots')
      groupState[g] = {people:[]}
      for(let p=1;p<=PAIRS_PER_GROUP;p++){
        const pair = document.createElement('div')
        pair.className='pair'
        pair.dataset.pair = p
        pair.innerHTML = `
          <div class="slot empty" data-slot="left" aria-label="Makker A">+ venstre</div>
          <div class="slot empty" data-slot="right" aria-label="Makker B">+ højre</div>
        `
        slots.appendChild(pair)
      }

      // Time controls: now button + dial
      const startNow = el.querySelector('.start-now')
      const startTime = el.querySelector('.startTime')
      const startDial = el.querySelector('.startDial')
      startNow.addEventListener('click',()=> setTimeToNow(startTime,startDial))
      startDial.addEventListener('input',()=>{
        startTime.value = minutesToTime(startDial.value)
      })
      startTime.addEventListener('input',()=>{
        startDial.value = timeToMinutes(startTime.value)
      })
    }

    function minutesToTime(min){
      min = Number(min)
      const hh = String(Math.floor(min/60)).padStart(2,'0')
      const mm = String(min%60).padStart(2,'0')
      return `${hh}:${mm}`
    }
    function timeToMinutes(t){
      if(!t) return 0
      const [hh,mm]=t.split(':').map(Number)
      return hh*60+mm
    }
    function setTimeToNow(timeEl,dialEl){
      const d = new Date()
      const hh = String(d.getHours()).padStart(2,'0')
      const mm = String(d.getMinutes()).padStart(2,'0')
      timeEl.value = `${hh}:${mm}`
      if(dialEl) dialEl.value = timeToMinutes(timeEl.value)
    }

    // Render roster
    function renderRoster(){
      rosterList.innerHTML=''
      const arr = [...people].sort(sortRoster)
      const query = filterInput.value.trim().toLowerCase()
      arr.forEach(p=>{
        if(query && !p.name.toLowerCase().includes(query)) return
        const node = createPersonNode(p)
        rosterList.appendChild(node)
      })
    }

    function createPersonNode(person){
      const tpl = document.getElementById('personTpl')
      const node = tpl.content.firstElementChild.cloneNode(true)
      node.querySelector('.name').textContent = person.name.replace(/\s*\([^)]*\)$/,'')
      node.querySelector('.badge').textContent = person.level === 'T' ? '(T)' : (person.level)
      node.dataset.level = person.level
      node.dataset.fullname = person.name
      node.classList.toggle('trainer', person.level === 'T')
      // pointer drag support
      node.addEventListener('pointerdown', startDrag)
      node.addEventListener('keydown', e=>{ if(e.key==='Enter') startDragKeyboard(e,node) })
      return node
    }

    filterInput.addEventListener('input', renderRoster)
    renderRoster()

    // Drag & drop implementation using pointer events (works on iPhone Safari with modern iOS)
    let dragItem = null
    let sourceContainer = null
    let ghost = null

    function startDragKeyboard(e,node){
      // keyboard: pick up and show instructions
      e.preventDefault()
      alert('Brug mus/pegefelt eller touch til at trække. Keyboard-dnd ikke implementeret.')
    }

    function startDrag(e){
      e.preventDefault()
      const target = e.currentTarget
      dragItem = target
      sourceContainer = target.parentElement
      target.classList.add('dragging')
      target.releasePointerCapture(e.pointerId)

      ghost = target.cloneNode(true)
      ghost.classList.add('ghost')
      document.body.appendChild(ghost)
      moveGhost(e.clientX,e.clientY)

      window.addEventListener('pointermove', onPointerMove)
      window.addEventListener('pointerup', onPointerUp)
    }
    function moveGhost(x,y){
      if(!ghost) return
      ghost.style.left = x + 'px'
      ghost.style.top = y + 'px'
    }
    function onPointerMove(e){
      moveGhost(e.clientX,e.clientY)
      // highlight current slot under pointer
      const el = document.elementFromPoint(e.clientX,e.clientY)
      document.querySelectorAll('.pair,.slot').forEach(n=>n.classList.remove('hover'))
      const slot = findSlotAncestor(el)
      if(slot) slot.classList.add('hover')
    }
    function findSlotAncestor(el){
      while(el && el !== document.body){
        if(el.classList && el.classList.contains('slot')) return el
        if(el.classList && el.classList.contains('pair')) return el
        el = el.parentElement
      }
      return null
    }
    function onPointerUp(e){
      window.removeEventListener('pointermove', onPointerMove)
      window.removeEventListener('pointerup', onPointerUp)
      if(ghost) ghost.remove(); ghost=null
      if(!dragItem) return
      dragItem.classList.remove('dragging')

      const dropEl = document.elementFromPoint(e.clientX,e.clientY)
      const slot = findSlotAncestor(dropEl)
      if(slot && slot.classList.contains('slot')){
        // drop into that slot if empty or replace
        assignToSlot(dragItem, slot)
      } else if(slot && slot.classList.contains('pair')){
        // drop to first empty child slot
        const left = slot.querySelector('[data-slot="left"]')
        const right = slot.querySelector('[data-slot="right"]')
        if(left && left.classList.contains('empty')) assignToSlot(dragItem,left)
        else if(right && right.classList.contains('empty')) assignToSlot(dragItem,right)
        else { // no space - return to roster
          unassignToRoster(dragItem)
        }
      } else {
        // if dropped on roster area, return to roster
        const rosterRect = rosterList.getBoundingClientRect()
        if(e.clientX >= rosterRect.left && e.clientX <= rosterRect.right && e.clientY >= rosterRect.top && e.clientY <= rosterRect.bottom){
          unassignToRoster(dragItem)
        } else {
          // else return element to original place
          if(sourceContainer && sourceContainer.classList.contains('slot')) {
            // leave where it was
          } else {
            // if coming from roster and dropped nowhere -> append back to roster
            if(sourceContainer && sourceContainer.id === 'rosterList') rosterList.appendChild(dragItem)
          }
        }
      }

      // cleanup highlights
      document.querySelectorAll('.pair,.slot').forEach(n=>n.classList.remove('hover'))
      dragItem = null
      updateAllGroupStates()
    }

    function createAssignedNode(originalNode){
      // Move node (not clone) -- we will reparent the original DOM node
      // But if original was in roster, it contains full name with level in dataset
      const node = originalNode
      node.style.touchAction='none'
      node.addEventListener('pointerdown', startDrag)
      node.setAttribute('draggable','false')
      return node
    }

    function assignToSlot(node, slotEl){
      // If node comes from roster list, we move it; if from another slot, also move
      // Ensure only max 1 person per slot
      if(!slotEl) return
      // if slot already has child person element, swap back to roster
      const existing = slotEl.querySelector('.person')
      if(existing){
        // send existing back to roster
        rosterList.appendChild(existing)
      }
      // append the actual node
      const moved = createAssignedNode(node)
      // Ensure name shows only base name
      if(moved.dataset.fullname) moved.querySelector('.name').textContent = moved.dataset.fullname.replace(/\s*\([^)]*\)$/,'')
      slotEl.classList.remove('empty')
      // If node came from roster, it's already the element; if it came from somewhere else, it will be moved automatically
      slotEl.appendChild(moved)
    }

    function unassignToRoster(node){
      // move node back to roster
      rosterList.appendChild(node)
    }

    // click to remove person from slot (secondary small x)? Add double-click to send back
    document.addEventListener('dblclick', e=>{
      const p = e.target.closest('.person')
      if(!p) return
      // if the person is inside a slot, move back to roster
      const slot = p.closest('.slot')
      if(slot){
        unassignToRoster(p)
        slot.classList.add('empty')
        updateAllGroupStates()
      }
    })

    // Keep group state up to date: count trainers per group and show missing-trainer class
    function updateAllGroupStates(){
      document.querySelectorAll('.group').forEach(gEl=>{
        const trainerCount = gEl.querySelectorAll('.person.trainer').length
        gEl.querySelector('.trainerCount').textContent = trainerCount
        if(trainerCount===0) gEl.classList.add('missing-trainer')
        else gEl.classList.remove('missing-trainer')
      })
    }

    // Make roster accept drops (when items are dropped back)
    rosterList.addEventListener('pointerup', e=>{
      // handled in pointerup
    })

    // Accessibility: provide touch-friendly hints
    document.addEventListener('touchmove', ()=>{})

    // Initial update
    updateAllGroupStates()

    // Small helper: allow tapping slot to focus and then choose to place selected person - not implemented

    // Note: This is a compact, self-contained drag implementation. It moves DOM nodes (no copy) and is built to work on modern iOS/Android using pointer events.
  </script>

</body>
</html>
